name: Build and Test (Windows)

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

permissions:
  contents: read
  pull-requests: write

jobs:
  build:
    name: Build (Windows MSVC)
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up MSVC
        uses: microsoft/setup-msbuild@v1.1

      # LLVM 20.1.8 is pinned for stability and coverage tool compatibility
      # This version is verified to work with our LLVM-based coverage workflow
      - name: Install LLVM (for coverage)
        run: |
          choco install llvm --version=20.1.8 -y
          echo "C:\Program Files\LLVM\bin" >> $GITHUB_PATH
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      # vcpkg binary cache speeds up dependency builds by caching compiled packages
      - name: Restore vcpkg binary cache
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/vcpkg/archives
          key: vcpkg-bincache-${{ runner.os }}-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
          restore-keys: |
            vcpkg-bincache-${{ runner.os }}-

      # Cache installed packages to avoid rebuilding dependencies on every run
      - name: Cache vcpkg installed packages
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/build/vcpkg_installed
          key: vcpkg-installed-${{ runner.os }}-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
          restore-keys: |
            vcpkg-installed-${{ runner.os }}-

      # vcpkg commit is pinned to ensure reproducible builds across environments
      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgGitCommitId: "a62ce77d56ee07513b4b67de1ec2daeaebfae51a"

      - name: Configure CMake
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake"
        shell: bash

      - name: Build
        run: cmake --build build --config Release --parallel

      # Artifacts retained for 1 day to minimize storage costs
      # Build artifacts only needed for test job dependency
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-build-release
          path: |
            build/bin/Release/
            build/tests/Release/
          retention-days: 1

  test:
    name: Test (Windows MSVC)
    runs-on: windows-latest
    needs: build

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: windows-build-release
          path: build/

      - name: Run Tests
        run: |
          cd build
          ctest --output-on-failure -C Release
        shell: bash

  # Coverage runs on Windows with Clang because:
  # - LLVM coverage tools (llvm-profdata, llvm-cov) provide better instrumentation
  # - Clang's source-based coverage is more reliable than MSVC alternatives
  # - Linux coverage was removed to reduce CI time and focus on primary platform
  coverage:
    name: Coverage (Windows Clang)
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up MSVC
        uses: microsoft/setup-msbuild@v1.1

      - name: Install LLVM and Ninja
        run: |
          choco install llvm --version=20.1.8 -y
          choco install ninja -y
          echo "C:\Program Files\LLVM\bin" >> $GITHUB_PATH
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Restore vcpkg binary cache
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/vcpkg/archives
          key: vcpkg-bincache-${{ runner.os }}-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
          restore-keys: |
            vcpkg-bincache-${{ runner.os }}-

      - name: Cache vcpkg installed packages
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/build/vcpkg_installed
          key: vcpkg-installed-${{ runner.os }}-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
          restore-keys: |
            vcpkg-installed-${{ runner.os }}-

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgGitCommitId: "a62ce77d56ee07513b4b67de1ec2daeaebfae51a"

      # RelWithDebInfo provides debug symbols for coverage while maintaining performance
      # Ninja generator is required for proper LLVM coverage flag handling with Clang
      - name: Configure CMake (RelWithDebInfo)
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_C_COMPILER=clang \
            -DCMAKE_CXX_COMPILER=clang++ \
            -DENABLE_COVERAGE=ON \
            -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake" \
            -G Ninja
        shell: bash

      - name: Build with Coverage
        run: cmake --build build --parallel

      - name: Generate Test Coverage Report
        run: |
          python scripts/run-coverage.py --no-build
        shell: bash
        continue-on-error: true

      # Coverage reports retained for 30 days for historical analysis and tracking
      - name: Upload Coverage HTML Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-windows
          path: build/coverage/html/
          retention-days: 30

      - name: Display Coverage Summary in Workflow
        if: always()
        run: |
          echo "## ðŸ“Š Test Coverage Report (Windows)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -d build/coverage/html ]; then
            echo "âœ… Coverage report generated successfully" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“ Full HTML report available in artifacts" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Coverage report not generated" >> $GITHUB_STEP_SUMMARY
          fi
        shell: bash
        continue-on-error: true

      - name: Extract Coverage Statistics
        if: always()
        id: coverage-stats
        run: |
          if [ -f build/coverage/coverage.profdata ]; then
            # Generate coverage report and extract statistics
            TEST_EXE="build/tests/TestVisionCraftNodes.exe"
            PROFDATA="build/coverage/coverage.profdata"

            # Get coverage summary
            llvm-cov report "$TEST_EXE" -instr-profile="$PROFDATA" > coverage-summary.txt

            # Extract overall coverage percentage (last line of summary)
            TOTAL_LINE=$(tail -n 1 coverage-summary.txt)

            # Parse the coverage percentage from the TOTAL line
            # Format: "TOTAL  X  Y  Z%  A  B  C%  D  E  F%"
            REGIONS_COV=$(echo "$TOTAL_LINE" | awk '{print $4}' | tr -d '%')
            FUNCTIONS_COV=$(echo "$TOTAL_LINE" | awk '{print $7}' | tr -d '%')
            LINES_COV=$(echo "$TOTAL_LINE" | awk '{print $10}' | tr -d '%')

            echo "regions_coverage=$REGIONS_COV" >> $GITHUB_OUTPUT
            echo "functions_coverage=$FUNCTIONS_COV" >> $GITHUB_OUTPUT
            echo "lines_coverage=$LINES_COV" >> $GITHUB_OUTPUT
            echo "coverage_available=true" >> $GITHUB_OUTPUT
          else
            echo "coverage_available=false" >> $GITHUB_OUTPUT
          fi
        shell: bash
        continue-on-error: true

      - name: Post Coverage Comment to PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const coverageDir = 'build/coverage/html';
            const coverageExists = fs.existsSync(coverageDir);

            let body = '## ðŸ“Š Test Coverage Report (Windows)\n\n';

            if (coverageExists && '${{ steps.coverage-stats.outputs.coverage_available }}' === 'true') {
              const regionsCov = '${{ steps.coverage-stats.outputs.regions_coverage }}';
              const functionsCov = '${{ steps.coverage-stats.outputs.functions_coverage }}';
              const linesCov = '${{ steps.coverage-stats.outputs.lines_coverage }}';

              body += 'âœ… Coverage report generated successfully\n\n';
              body += '### Coverage Statistics\n\n';
              body += '| Metric | Coverage |\n';
              body += '|--------|----------|\n';
              body += `| **Lines** | ${linesCov}% |\n`;
              body += `| **Functions** | ${functionsCov}% |\n`;
              body += `| **Regions** | ${regionsCov}% |\n`;
              body += '\n';
              body += `ðŸ“ [Full HTML Report](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;
            } else {
              body += 'âš ï¸ Coverage report not generated';
            }

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Test Coverage Report (Windows)')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
        continue-on-error: true
