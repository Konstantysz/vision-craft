name: Coverage

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

permissions:
  contents: read
  pull-requests: write

jobs:
  coverage:
    name: Coverage (Windows Clang)
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up MSVC
        uses: microsoft/setup-msbuild@v1.1

      - name: Install LLVM and Ninja
        run: |
          choco install llvm --version=20.1.8 -y
          choco install ninja -y
          echo "C:\Program Files\LLVM\bin" >> $GITHUB_PATH
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Restore vcpkg binary cache
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/vcpkg/archives
          key: vcpkg-bincache-${{ runner.os }}-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
          restore-keys: |
            vcpkg-bincache-${{ runner.os }}-

      - name: Cache vcpkg installed packages
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/build/vcpkg_installed
          key: vcpkg-installed-${{ runner.os }}-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
          restore-keys: |
            vcpkg-installed-${{ runner.os }}-

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgGitCommitId: "a62ce77d56ee07513b4b67de1ec2daeaebfae51a"

      # RelWithDebInfo provides debug symbols for coverage while maintaining performance
      # Ninja generator is required for proper LLVM coverage flag handling with Clang
      - name: Configure CMake (RelWithDebInfo)
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_C_COMPILER=clang \
            -DCMAKE_CXX_COMPILER=clang++ \
            -DENABLE_COVERAGE=ON \
            -DBUILD_TESTS=ON \
            -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake" \
            -G Ninja
        shell: bash

      - name: Generate Test Coverage Report
        run: python scripts/run-coverage.py
        shell: bash
        continue-on-error: true

      - name: Upload Coverage HTML Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-windows
          path: build/coverage/html/
          retention-days: 30

      - name: Display Coverage Summary in Workflow
        if: always()
        run: |
          echo "## ðŸ“Š Test Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -d build/coverage/html ]; then
            echo "âœ… Coverage report generated successfully" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“ Full HTML report available in artifacts" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Coverage report not generated" >> $GITHUB_STEP_SUMMARY
          fi
        shell: bash
        continue-on-error: true

      - name: Extract Coverage Statistics
        if: always()
        id: coverage-stats
        run: |
          if [ -f build/coverage/coverage.profdata ]; then
            TEST_EXE="build/tests/TestVisionCraftNodes.exe"
            PROFDATA="build/coverage/coverage.profdata"

            llvm-cov report "$TEST_EXE" -instr-profile="$PROFDATA" > coverage-summary.txt
            TOTAL_LINE=$(tail -n 1 coverage-summary.txt)

            REGIONS_COV=$(echo "$TOTAL_LINE" | awk '{print $4}' | tr -d '%')
            FUNCTIONS_COV=$(echo "$TOTAL_LINE" | awk '{print $7}' | tr -d '%')
            LINES_COV=$(echo "$TOTAL_LINE" | awk '{print $10}' | tr -d '%')

            echo "regions_coverage=$REGIONS_COV" >> $GITHUB_OUTPUT
            echo "functions_coverage=$FUNCTIONS_COV" >> $GITHUB_OUTPUT
            echo "lines_coverage=$LINES_COV" >> $GITHUB_OUTPUT
            echo "coverage_available=true" >> $GITHUB_OUTPUT
          else
            echo "coverage_available=false" >> $GITHUB_OUTPUT
          fi
        shell: bash
        continue-on-error: true

      - name: Post Coverage Comment to PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const coverageDir = 'build/coverage/html';
            const coverageExists = fs.existsSync(coverageDir);

            let body = '## ðŸ“Š Test Coverage Report\n\n';

            if (coverageExists && '${{ steps.coverage-stats.outputs.coverage_available }}' === 'true') {
              const regionsCov = '${{ steps.coverage-stats.outputs.regions_coverage }}';
              const functionsCov = '${{ steps.coverage-stats.outputs.functions_coverage }}';
              const linesCov = '${{ steps.coverage-stats.outputs.lines_coverage }}';

              body += 'âœ… Coverage report generated successfully\n\n';
              body += '### Coverage Statistics\n\n';
              body += '| Metric | Coverage |\n';
              body += '|--------|----------|\n';
              body += `| **Lines** | ${linesCov}% |\n`;
              body += `| **Functions** | ${functionsCov}% |\n`;
              body += `| **Regions** | ${regionsCov}% |\n`;
              body += '\n';
              body += `ðŸ“ [Full HTML Report](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;
            } else {
              body += 'âš ï¸ Coverage report not generated';
            }

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Test Coverage Report')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
        continue-on-error: true
